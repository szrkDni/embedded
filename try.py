"""Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
Embedded Systems Laboratory
Lab 5: Sensors on the Sense HAT
Project overview
The Sense HAT has a set of environmental sensors for detecting the surrounding conditions.
It can measure orientation, pressure, temperature, and humidity. The main topic of this lab is
the data acquisition from Sense HAT‚Äôs sensors.
The following topics will be covered in this lab:
‚Ä¢ Sense HAT - sensors
Technical requirements
The following components are required to complete this lab:
‚Ä¢ Raspberry Pi 3 Model B+ (MicroSD card, power supply, keyboard, mouse)
‚Ä¢ Sense HAT
‚Ä¢ Or you can use the emulator!
1. Sense HAT
The HAT includes the following components:
‚Ä¢ 8x8 LED matrix display
‚Ä¢ Accelerator
‚Ä¢ Gyroscope
‚Ä¢ Magnetometer
‚Ä¢ Air pressure sensor
‚Ä¢ Temperature sensor
‚Ä¢ Humidity sensor
‚Ä¢ Small joystick
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
2. Atmospheric pressure
‚Ä¢ Atmospheric or air pressure is the force per unit of area exerted on the Earth‚Äôs surface
by the weight of the air above the surface
‚Ä¢ Atmospheric pressure is expressed in several different systems of units. With SI
(International System of Units) units, pressure measures force per unit area - Pascals
(1 pascal = 1 newton per square meter, 1 N/m2)
‚Ä¢ Standard sea-level pressure, by definition is equal to 101.325 kilopascal (kPa) =
1013.25 hPa
‚Ä¢ The pressure (and temperature) sensor on the HAT is LPS25H:
o 260 to 1260 hPa pressure range (accuracy depends on the temperature and
pressure, ~0.1 hPa under normal conditions)
o SPI and I2C interfaces
‚Ä¢ Pressure increases as temperatures increase and decreases as temperature cool down
‚Ä¢ Pressure increases at lower altitudes and decreases at higher altitudes. Therefore, air
pressure is highest at sea level, where air density is greatest
‚Ä¢ Read pressure value from the HAT‚Äôs sensor: get_pressure()
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
3. Humidity
‚Ä¢ Humidity is the amount of water vapor present in air
‚Ä¢ Humidity indicates the likelihood for precipitation, dew, or fog to be present
‚Ä¢ The amount of water vapor needed to achieve saturation increases as the temperature
increases
‚Ä¢ Two primary measurements of humidity are widely employed: absolute and relative:
o Absolute humidity describes the water content of air and is typically expressed
in grams per cubic meter g/m3
o Relative humidity (RH), expressed as a percentage. It is a measure of the
amount of water vapor that air is holding compared the amount it can hold at
a specific temperature. At 100% relative humidity, the air is saturated (its
dewpoint)
‚Ä¢ The humidity (and temperature) sensor on the HAT is HTS225:
o 0 to 100% relative humidity range
o Temperature accuracy: ¬± 0.5 ¬∞C, 15 to +40 ¬∞C
o SPI, I2C interfaces
‚Ä¢ Read humidity value from the HAT‚Äôs sensor: get_humidity()
Height
Pressure
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
4. Temperature
‚Ä¢ The Sense HAT has two sensors capable of reading the ambient temperature:
o Humidity sensor
o Pressure sensor
‚Ä¢ Most commonly used scales of temperature:
o Celsius (C)
o Fahrenheit (F)
o Kelvin (K - the unit of temperature in SI)
‚Ä¢ Many physical processes are affected by temperature. For example, the physical
properties of materials
‚Ä¢ Read temperature from the HAT‚Äôs humidity sensor: get_temperature()
‚Ä¢ Read temperature from the pressure sensor: get_temperature_from_pressure()
‚Ä¢ Unfortunately, the temperature measure on the HAT is not accurate due to the heat
generated by the Raspberry Pi. It can be used as a reference value only!
5. Acquire data from sensors
Read temperature, humidity and pressure values from sensors, one times in a second in an
infinite loop. Print the three values in a single line into the console.
5.1. Import necessary modules:
from sense_hat import SenseHat
from time import sleep
5.2. Create an object from the SenseHat class:
sense = SenseHat()
5.3. Acquire temperature, humidity, and pressure values in an infinite loop:
while True:
t = sense.get_temperature()
p = sense.get_pressure()
h = sense.get_humidity()
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
# round() - round the values to some decimal places
t = round(t, 1)
p = round(p, 1)
h = round(h, 1)
# str() ‚Äì convert a value to a string
message = "Temperature: " + str(t) + "C" + " Pressure: " +
str(p) + "hPa" + " Humidity: " + str(h) + "%"
print(message)
sleep(1)
6. Weather forecast (task to be solved alone)
Use simplified Zambretti‚Äôs algorithm to predict weather. The input parameters of the
algorithm are season, sea-level pressure, barometric tendency, hemisphere and wind
direction. The algorithm is empirical and created for the northern hemisphere (in Great
Britain). Analysis made on the algorithm conclude, that wind direction has little effect to the
final result, so it is negligible. We can read the temperature, humidity and station pressure
from the Sense HAT, but the relative pressure should be calculated. Using the following
algorithm, we will calculate a tabulated forecast number Z:
1. From your measured pressure P (in hPa), temperature T (in Celsius) and the altitude h
(in meter) compute the atmospheric pressure reduced to sea level P0. For simplicity,
the h value is a constant 125m.
ùëÉ0 = ùëÉ (1 ‚àí 0.0065 ‚àó ‚Ñé
ùëá + 0.0065 ‚àó ‚Ñé + 273.15)
‚àí5.257
2. The most significant factor in any weather forecast is whether the atmospheric
pressure is falling, rising, or steady. A falling barometer is indicated by a drop of 1.6
millibars (conversion between Bar and Pascal) within a three-hour period. If the
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
pressure rises 1.6 millibars within three hours, it is a rising barometer. If the pressure
neither rises nor falls it is steady. For simplicity, you should compute P0 just one-time
in a cycle:
a. If the pressure is falling and 985 <= ùëÉ0<= 1050, compute the forecast number
as ùíÅ = ùüèùüêùüï ‚àí ùüé. ùüèùüêùë∑ùüé. After that, use the following forecast table:
Z Forecast
1 Settled Fine
2 Fine Weather
3 Fine, Becoming Less Settled
4 Fairly Fine, Showery Later
5 Showery, Becoming More Unsettled
6 Unsettled, Rain Later
7 Rain at Times, Worse Later
8 Rain at Times, Becoming Very
Unsettled
9 Very Unsettled, Rain
b. If the pressure is steady and 960 <= ùëÉ0<= 1033, compute the forecast number
as ùíÅ = ùüèùüíùüí ‚àí ùüé. ùüèùüëùë∑ùüé. After that, use the following forecast table:
Z Forecast
10 Settled Fine
11 Fine Weather
12 Fine, Possibly Showers
13 Fairly Fine, Showers Likely
14 Showery, Bright Intervals
15 Changeable, Some Rain
16 Unsettled, Rain at Times
17 Rain at Frequent Intervals
18 Very Unsettled, Rain
c. If the pressure is rising and 947 <= ùëÉ0<= 1030, compute the forecast number
as ùíÅ = ùüèùüñùüì ‚àí ùüé. ùüèùüîùë∑ùüé. After that, use the following forecast table:
Z Forecast
20 Settled Fine
21 Fine Weather
22 Becoming Fine
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
23 Fairly Fine, Improving
24 Fairly Fine, Possibly Showers Early
25 Showery Early, Improving
26 Changeable, Mending
27 Rather Unsettled, Clearing Later
28 Unsettled, Probably Improving
29 Unsettled, Short Fine Intervals
30 Very Unsettled, Finer at Times
31 Stormy, Possibly Improving
32 Stormy, Much Rain
7. Weather logger
Collect temperature and humidity data from the Sense HAT‚Äôs sensors in every 0.5 seconds
until 5 seconds and log it to a .txt file. Thereafter, use the matplotlib module to display that
data as a line graph.
7.1. Install the matplotlib. In the terminal issue the following command:
$pip3 install matplotlib
7.2. Install an additional module:
$sudo apt-get install libatlas-base-dev
7.3. Import necessary libraries:
from sense_hat import SenseHat
import matplotlib.pyplot as plt
import time
7.4. Define the data visualisation function which reads data from file:
def plot(filename):
#define two lists
temp_list = []
humi_list = []
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
try:
#open the file for read
file = open(filename, ‚Äòr‚Äô)
#break file content into lines
lines = file.readlines()
#go through all lines and split lines by ‚Äò,‚Äô
for line in lines:
values = line.split(‚Äò,‚Äô)
temp_list.append(float(values[0]))
humi_list.append(float(values[1]))
finally:
file.close()
#create graph using the plot function from matplotlib
# arguments of the plot function: x values, y values, line_type
plt.plot(range(1, len(temp_list) + 1), temp_list, ‚Äòr-‚Äô)
plt.plot(range(1, len(humi_list) + 1), humi_list, ‚Äòb--‚Äô)
plt.title(‚ÄòWeather‚Äô)
plt.xlabel(‚ÄòMeasurements‚Äô)
plt.ylabel(‚ÄòValue‚Äô)
plt.show()
7.5. Data acquisition is in the main() function:
def main():
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
sense = SenseHat()
#time() ‚Äì return the time in seconds
start_time = time.time()
stop_time = time.time()
filename = ‚Äòweather.txt‚Äô
#open file for append
file = open(filename, ‚Äòa‚Äô)
print(‚ÄòData acquisition is starting‚Ä¶‚Äô)
while stop_time ‚Äì start_time < 5:
file.write(str(sense.get_temperature()) + ‚Äò,‚Äô +
str(sense.get_humidity()))
file.write(‚Äò\n‚Äô)
stop_time = time.time()
print(‚ÄòStop data acquisition!‚Äô)
file.close()
plot(filename)
if __name__ == ‚Äò__main__‚Äô:
main()
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
8. Using pressure value to predict altitude (task to be solved
alone)
Write a Python program which tries to predict your altitude. Print the predicted value into
the console window!
‚Ä¢ Near Earth‚Äôs surface the pressure decreases by about 1.2 kPa for every 100 meters but
it also depends on the temperature
‚Ä¢ A change of 1 hPa of atmospheric pressure corresponds to a change in altitude
of about 8.3 meters.
‚Ä¢ Altitude can be calculated using the international barometric formula (in meter):
‚Ñé = 44331 ‚àó (1 ‚àí ( ùëÉ
ùëÉ0
)
1
5.2558
)
P ‚Äì atmospheric pressure at current location in hPa
P0 ‚Äì atmospheric pressure at sea level in hPa (1013.25 hPa)
‚Ä¢ Find altitude on map (online): https://www.daftlogic.com/sandbox-google-maps-find-
altitude.htm
9. Detecting movement
‚Ä¢ The Sense HAT has an 9 DOF (degrees of freedom) IMU (inertial measurement unit)
chip which includes a set of sensors that detect movement:
o Gyroscope: measures rotation
o Accelerometer: measures acceleration forces, can be used to find the direction
of gravity
o Magnetometer: measures the Earth‚Äôs own magnetic field
‚Ä¢ All objects have three axes around which they can rotate:
o Pitch ‚Äî rotation around y axis
o Roll ‚Äî rotation around x axis
o Yaw ‚Äî rotation around z axis
‚Ä¢ If you know how much rotation has happened on each axis of an object, then you know
which way the object is pointing.
‚Ä¢ Access orientation data: get_orientation()
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
10. Detecting acceleration and rotation
Write a program to detect acceleration on each axis and the current pitch, roll, and yaw. Run
the program and move the Sense HAT. Watch how the values change as the Sense HAT moves.
10.1. Create a SenseHat object.
10.2. Get orientation:
o = sense.get_orientation()
10.3. Get acceleration:
acceleration = sense.get_accelerometer_raw()
10.4. Extract components from orientation:
pitch = o["pitch"]
roll = o["roll"]
yaw = o["yaw"]
10.5. Extract components from acceleration and round their values:
x = acceleration['x']
y = acceleration['y']
z = acceleration['z']
x=round(x, 0)
X
Y
Z
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
y=round(y, 0)
z=round(z, 0)
10.6. Print out all values:
print("pitch: ‚Äù, pitch, ‚Äú roll: ‚Äù, roll, ‚Äú yaw: ‚Äù, yaw)
print("x: ‚Äù, x, ‚Äú y: ‚Äù, y, ‚Äú z: ‚Äù, z)
11. Walking pet (task to be solved alone)
Write a Python program which animates a walking pet (cat)!
11.1. Design two similar pet patterns where the only difference is the leg
position. The difference between leg positions helps as animate movement.
11.2. To animate the movement, you need to create a loop where the two pet
patterns will be repeatedly switched every half-second. This code needs to
be placed in a function which will be called if a trigger event occurs.
11.3. Use the Sense HAT‚Äôs movement sensor to generate a trigger event. You
need to read accelerometer values and calculate the length of the force with
the following formula:
ùêπ = ‚àöùë•2 + ùë¶2 + ùëß2
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
If F is higher than a predefined threshold (trigger event), the above-
described walk function will be called.
12. Electronic compass
The earth‚Äôs magnetic field can be approximated with the dipole model shown below. This
figure illustrates that the earth‚Äôs field points down toward north in the northern hemisphere,
is horizontal and pointing north at the equator, and point up toward north in the southern
hemisphere. In all cases, the direction of the earth‚Äôs field is always pointing to magnetic north.
It is the components of this field that are parallel to the earth‚Äôs surface that are used to
determine compass direction.
The term magnetic north refers to the earth‚Äôs magnetic pole position and differs from true, or
geographic, north. True north is at the earth‚Äôs rotational axis and is referenced by the meridian
lines found on maps. At different locations around the globe magnetic north and true north
can differ by ¬±25 degrees. The difference between them at your location can be found
on: http://magnetic-declination.com/. Since the magnetometer is fixed on the Printed Circuit
Board (PCB), their readings change according to the orientation of the PCB. If the PCB remains
flat, then the compass heading (or azimuth) could be computed with a two-step process:
1. Determine the Hx and Hy horizontal components of the earth‚Äôs magnetic field
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
2. Add or subtract the proper declination angle to correct for true north.
To account for the tangent function being valid over 180¬∞ and not allowing the zero-division
calculation, the following formula can be used:
ùõº =
{
90 ùëñùëì (ùë• = 0, ùë¶ < 0)
270 ùëñùëì (ùë• = 0, ùë¶ > 0)
360 + arctan (ùë¶
ùë•) ‚àó 180
ùúã ùëñùëì (ùë¶ < 0)
arctan (ùë¶
ùë•) ‚àó 180
ùúã ùëñùëì (ùë¶ > 0)
The arcus tangent function can be calculated by the atan2(y,x) function. It gives back the result
in radian between -œÄ and œÄ. To convert radian into degree the following simple equation has
been used:
ùõºùëëùëíùëîùëüùëíùëí = ùõºùëüùëéùëëùëñùëéùëõ ‚àó 180/ùúã
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
13. 4-piont compass
A simple four-point compass depicts the cardinal points (N, S, E, W). This type of compass may
be used for basic automotive use where the driver needs to know the general direction of
travel. For this application, the magnetic sensor can be reduced to a two-axis sensor using only
the X and Y axis.
x
y
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
13.1. Import necessary libraries.
13.2. Create a global calibration variable:
calibration = True
13.3. Define stop function which will terminate the calibration process.
def stop():
global calibration
calibration = False
13.4. Use a modified version of the plot() function to visualize the acquired x
and y values of the magnetometer. The function gives back the max and min
values of x and y.
def plot(filename):
#define two lists
x_list = []
y_list = []
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
try:
#open the file for read
file = open(filename, ‚Äòr‚Äô)
#break file content into lines
lines = file.readlines()
#go through all lines
for line in lines:
values = line.split(‚Äò,‚Äô)
x_list.append(float(values[0]))
y_list.append(float(values[1]))
finally:
file.close()
#max-min values
xmax = max(x_list)
xmin = min(x_list)
ymax = max(y_list)
ymin = min(y_list)
print(‚ÄòMax x: ‚Äô, xmax, ‚ÄòMin x: ‚Äô, xmin)
print(‚ÄòMax y: ‚Äô, ymax, ‚ÄòMin y: ‚Äô, ymin)
#create graph
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
line1, = plt.plot(range(1, len(x_list) + 1), x_list, ‚Äòr-‚Äô, label=‚Äôx‚Äô)
line2, = plt.plot(range(1, len(y_list) + 1), y_list, ‚Äòb--‚Äô, label=‚Äôy‚Äô)
plt.xlabel(‚ÄòMeasurements‚Äô)
plt.ylabel(‚ÄòValue‚Äô)
plt.legend(handles=[line1, line2])
plt.show()
return xmax, xmin, ymax, ymin
13.5. In the main there are two loops. The first is a the calibration loop. It is
terminated by the joystick push. During calibration, you have to turn
around your Pi (in place on a flat surface) and than push the joystick!
Acquired data will be drawn by the plot() fucntion.
def main():
sense = SenseHat()
filename = ‚Äòcompass.txt‚Äô
#open file for write (rewrite its content)
file = open(filename, ‚Äòw‚Äô)
sense.stick.direction_middle = stop
print(‚ÄòStart data acquisition‚Ä¶‚Äô)
#calibration process
while calibration:
magnet = sense.get_compass_raw()
x = magnet[‚Äòx‚Äô]
y = magnet[‚Äòy‚Äô]
file.wtite(str(x) + ‚Äò,‚Äô + str(y) + ‚Äò\n‚Äô)
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
file.close()
xmax, xmin, ymax, ymin = plot(filename)
13.6. Unfortunately, the surrounding environment can significantly influence
magnetometer‚Äôs operation. To deal with this problem, we will use range
transformation:
ùëì(ùë°) = ùëê + ùëë ‚àí ùëê
ùëè ‚àí ùëé (ùë° ‚àí ùëé)
It map the interval [a,b] onto the interval [c,d] ([-1,1] in our case). In ideal
case, the relationship between transformed x, y values can be seen on the
next figure (your plot is not so regular and may be phase shifted).
while True:
magnet = sense.get_compass_raw()
x = magnet[‚Äòx‚Äô]
y = magnet[‚Äòy‚Äô]
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
#range transform
xz = -1 + ((1-(-1)) / (xmax - xmin)) * (x - xmin)
yz = -1 + ((1-(-1)) / (ymax - ymin)) * (y - ymin)
#degree (a) calculation
if xz == 0 and yz < 0:
deg = 90
elif xz == 0 and yz > 0:
deg = 270
elif yz < 0:
deg = 360 + math.atan2(yz, xz) * (180/3.14159)
else:
deg = math.atan2(yz, xz) * (180/3.14159)
#cardinal points
if deg < 45 or deg > 315:
sense.show_letter(‚ÄòN‚Äô)
elif deg < 135:
sense.show_letter(‚ÄòE‚Äô)
elif deg < 225:
sense.show_letter(‚ÄòS‚Äô)
else:
sense.show_letter(‚ÄòW‚Äô)
time.sleep(0.2)
Dr. J√≥zsef S√ºt≈ë
Department of IT Systems and Networks
sense.clear()
13.7. Try out the application. Do not forget the calibration process!
14. 8-piont compass (task to be solved alone)
Extend the above 4-point compass to an 8-point compass. It depicts both cardinal (N, S, E, W)
and intermediate (NE, SE, SW, NW) points (use the earlier figure as reference).
References
[1] Raspberry Pi projects, https://projects.raspberrypi.org/en. Accessed on 10/01/2020.
This work was supported by the construction EFOP-3.4.3-16-2016-00021. The project was
supported by the European Union, co-financed by the European Social Fund."""